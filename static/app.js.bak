// Add scrollbar indicators to tables
document.addEventListener("DOMContentLoaded", () => {
  const tableContainers = document.querySelectorAll(".table-container")

  tableContainers.forEach((container) => {
    // Add scroll indicators if content is scrollable
    container.addEventListener("scroll", () => {
      const maxScroll = container.scrollHeight - container.clientHeight

      if (maxScroll > 0) {
        if (container.scrollTop === 0) {
          container.classList.remove("scroll-top")
        } else {
          container.classList.add("scroll-top")
        }

        if (container.scrollTop >= maxScroll - 5) {
          container.classList.remove("scroll-bottom")
        } else {
          container.classList.add("scroll-bottom")
        }
      }
    })

    // Trigger scroll event to initialize indicators
    container.dispatchEvent(new Event("scroll"))
  })
  
  // Handle collapsible panels
  const panelHeaders = document.querySelectorAll(".panel-header[data-panel-target]")

  panelHeaders.forEach((header) => {
    const targetId = header.getAttribute("data-panel-target")
    const panelBody = document.querySelector(targetId)
    const collapseIcon = header.querySelector(".collapse-icon")

    // Initialize collapse icons based on panel state
    if (panelBody.classList.contains("collapsed")) {
      collapseIcon.classList.add("collapsed")
    }

    header.addEventListener("click", () => {
      // Toggle the panel body
      panelBody.classList.toggle("collapsed")

      // Toggle the collapse icon
      collapseIcon.classList.toggle("collapsed")
    })
  })

  // Chat widget functionality
  const chatIcon = document.getElementById("chatIcon")
  const chatPanel = document.querySelector(".chat-panel")
  const closeChat = document.getElementById("closeChat")
  const messageInput = document.getElementById("messageInput")
  const sendMessage = document.getElementById("sendMessage")
  const chatMessages = document.getElementById("chatMessages")
  const userInput = "CONVERSATION between Relationship Manager and Client (Mr. Tan) - \nRELATIONSHIP MANAGER: Hello Mr. Tan how are you? You makan already? \nCLIENT: Makan already. What about you? \nRELATIONSHIP MANAGER: Me too, thanks! I am calling you today because there is a new high-return investment opportunity called the Great Fund. It primarily invests in emerging markets, small-cap stocks, and alternative assets. This kind of investments has very high returns. It will make you a lot of money!  \nCLIENT: Sure or not? Is it going to be risky? \nRELATIONSHIP MANAGER: Aiyoo! Don’t worry, the risk is very minimal. The fees can be covered by the huge returns you will be making eventually. At most you will lose about 1% of your investment. \nCLIENT: What kind of returns are we talking about? \nRELATIONSHIP MANAGER: The Great Fund projects an average annual return of 20% year on year. Very shiok right? \nCLIENT: Hmm ok! I am interested in investing about 1 million SGD but need more information first. Oh, just to be sure, I can only afford to lose 100,000 SGD max on this, ok? \nRELATIONSHIP MANAGER: Ok!  This investment plan is the key to further enabling your financial freedom, with your current net worth, you can definitely afford this, and even use it as a trust fund for your grandchildren!  Once I have the paper work ready, I’ll invite you to our branch at Yio Chu Kang for signing. \nCLIENT: Thanks! I'll wait for the paperwork. Bye!"
  

  // Toggle chat panel
  chatIcon.addEventListener("click", () => {
    chatPanel.classList.toggle("hidden")
    if (!chatPanel.classList.contains("hidden")) {
      messageInput.focus()
      scrollChatToBottom()
    }
  })

  // Close chat panel
  closeChat.addEventListener("click", (e) => {
    e.stopPropagation() // Prevent event from bubbling to panel header
    chatPanel.classList.add("hidden")
  })

  

  // Function to scroll chat to bottom
  function scrollChatToBottom() {
    chatMessages.scrollTop = chatMessages.scrollHeight
  }

  function callSummary(){
    const endPoint = "https://bankcallsummaryapi.eastus2.inference.ml.azure.com/score";
    const apiKey = "6aUGLhpcFSUxOmTTFSCqDoAogSPEhUD2whNJu0QNtXFjKN3sd74KJQQJ99BCAAAAAAAAAAAAINFRAZML3WEc";
    const finalUserInput = userInput + "\nsummarize the call in tabular format";
    
    callRAGEndpoint(finalUserInput, endPoint, apiKey, 'divCallSummary', function(result) {
      var output = formatResult(result)
      $('#divCallSummary').append(output);
    });
    
  }

  function trainingSummary(){
    const endPoint = "https://trainingprogram.eastus2.inference.ml.azure.com/score";
    const apiKey = "3ts1E6u7256t2KHitZqiMelvNCP5ywMqFIHT2YbS30WT2TBRHakeJQQJ99BCAAAAAAAAAAAAINFRAZML4V0a";
    const finalUserInput = userInput + "\nGrade the above RM-customer conversation (no need to show the grading) and provide training recommendations for the RM against this list of training programs. Show the Training plan in a neat table format.";
    
    callRAGEndpoint(finalUserInput, endPoint, apiKey, 'divTrainingModule', function(result) {
      var output = formatResult(result)
      $('#divTrainingModule').append(output);
    });
    
  }

  function rmGrading(){
    const endPoint = "https://rmgrading.eastus2.inference.ml.azure.com/score";
    const apiKey = "4OJOyNk8Y1Xn0JRSsyIxXEMRQ0iNhdQ5D0rxjZuMTRRamUAVIB8KJQQJ99BCAAAAAAAAAAAAINFRAZML3YIB";
    const finalUserInput = userInput + "\nGrade the RM’s performance in the conversation against the 10 standards in the Bank’s policy document provided above.";
    
    callRAGEndpoint(finalUserInput, endPoint, apiKey, 'divrmGrading', function(result) {
      var output = formatResult(result)
      $('#divrmGrading').append(output);
    });
  }

  function redoneConversation(){
    const endPoint = "https://redoneconversation.eastus2.inference.ml.azure.com/score";
    const apiKey = "CjJCwCMqNCLKBV4lwWIq6lIxAsW2f9xkxQhlBbMMP5DrjPo82PveJQQJ99BCAAAAAAAAAAAAINFRAZML2mYc";
    const finalUserInput = userInput + "\nRedo the above conversation in a compliant manner, and display it in a neat manner with a header at the start (in markdown format)";
    
    callRAGEndpoint(finalUserInput, endPoint, apiKey, 'divredoneConversation', function(result) {
      var output = formatResult(result)
      $('#divredoneConversation').append(output);
    });
  }

  // Send message function
  function addMessage(message, isUser = false) {
    const messageDiv = document.createElement("div")
    messageDiv.className = `message ${isUser ? "user" : "bot"}`
    
    chatMessages.appendChild(messageDiv)
    if(isUser){
      messageDiv.textContent = message
    }
    else{
      typeMessage(messageDiv, message);
    }    
    chatMessages.scrollTop = chatMessages.scrollHeight
  }

  // Handle sending messages
  function handleSendMessage() {
    const message = messageInput.value.trim()
    if (message) {
      addMessage(message, true)
      messageInput.value = ""

      // Simulate bot response with typing indicator
      const typingIndicator = document.createElement("div")
      typingIndicator.className = "message bot typing"
      typingIndicator.textContent = "Thinking..."
      chatMessages.appendChild(typingIndicator)
      chatMessages.scrollTop = chatMessages.scrollHeight
      
      const endPoint = "https://chatbot.eastus2.inference.ml.azure.com/score";
      const apiKey = "1rRTRaG3TOZcxf3ZXRvG4OXlPc8gP8HtpUjLhrCLRR74Eqdd13lCJQQJ99BCAAAAAAAAAAAAINFRAZML1Ujs";
      callRAGEndpoint(message, endPoint, apiKey, 'chatMessages', function(result) {
        chatMessages.removeChild(typingIndicator)
        addMessage(result);
        
      });
      
      // Random delay between 1-2 seconds to simulate typing
      // setTimeout(
      //   () => {
      //     // Remove typing indicator
          
          
      //   },
      //   1000 + Math.random() * 1000,
      // )
    }
  }

  sendMessage.addEventListener("click", handleSendMessage)

  messageInput.addEventListener("keypress", (e) => {
    if (e.key === "Enter") {
      handleSendMessage()
    }
  })

  // Add focus to input when clicking anywhere in the chat container
  document.querySelector(".chat-container").addEventListener("click", (e) => {
    // Prevent the click from bubbling up to the panel header
    e.stopPropagation()
    messageInput.focus()
  })

  // Add hover effects to panels
  document.querySelectorAll(".panel").forEach((panel) => {
    panel.addEventListener("mouseenter", () => {
      panel.style.zIndex = "10"
    })

    panel.addEventListener("mouseleave", () => {
      panel.style.zIndex = "1"
    })
  })
  
  function callRAGEndpoint(userInput, endpointURL, apikey, divName, callback){
    $.ajax({
      url: '/ask',
      method: 'POST',
      data: { query: userInput, url: endpointURL, apikey: apikey},
      success: function(response) {
          if (response.answer) {            
            if (callback) callback(response.answer);          
          } else {
              $('#'+divName).append('<p><strong>Error:</strong> ' + response.error + '</p>');
          }
      },
      error: function() {
        $('#'+divName).append('<p><strong>Error:</strong> An error occurred while processing your request.</p>');
      }
    });

  }

  function typeMessage(element, message, speed = 10) {
      let index = 0;
      function type() {
          if (index < message.length) {
              element.textContent += message.charAt(index);
              index++;
              setTimeout(type, speed);
          }
          scrollChatToBottom()
      }
      type();
  }

  // Create typing indicator with animated dots
  function createTypingIndicator() {
    const typingDiv = document.createElement("div")
    typingDiv.className = "message bot typing-message"

    const indicatorSpan = document.createElement("div")
    indicatorSpan.className = "typing-indicator"

    // Create the three dots
    for (let i = 0; i < 3; i++) {
      const dot = document.createElement("span")
      indicatorSpan.appendChild(dot)
    }

    typingDiv.appendChild(indicatorSpan)
    return typingDiv
  }

  function formatResult(result){
    // Split text into lines
    const lines = result.split("\n").map(line => line.trim()).filter(line => line.length > 0);
  
    // Extract headers from the first row
    const headers = lines[0].split("|").map(col => col.trim()).filter(col => col);
    
    // Create table element
    let tableHTML = `<table class="table table-bordered"><thead class="table-dark"><tr>`;

    // Append table headers
    headers.forEach(header => {
        tableHTML += `<th>${header.replace(/\*\*/g, '')}</th>`; // Remove ** for bold
    });
    tableHTML += `</tr></thead><tbody>`;

    // Process remaining rows
    for (let i = 2; i < lines.length; i++) { // Skip separator line
        const columns = lines[i].split("|").map(col => col.trim()).filter(col => col);
        tableHTML += `<tr>`;
        columns.forEach(col => {
            tableHTML += `<td>${col.replace(/\*\*/g, '')}</td>`;
        });
        tableHTML += `</tr>`;
    }

    tableHTML += `</tbody></table>`;
  }
})

